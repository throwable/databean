Objetivos e ideas:
------------------

[x] Stepped Builders
    - Si el objeto no tiene campos obligatorios se usa simple builder:
        User.of() : User
    - Si el objeto tiene campos obligatorios se crea constructor con parametros:
        User.of("Anton", 18) : User
            o stepped builder:
        User.of()           // : UserBuilderName
            .name("Anton")  // : UserBuilderAge
            .age(18)        // : User

[x] @Nullable support: la idea es obligar por defecto manejar con valores nonnull.
    !! Usar no @Nullable sino @Nonnull dejando poner @Nullable a usuario
    - NO! propiedades @Nullable deben ser marcados escrictamente
    - si propiedad no está marcado como @Nullable puede ser uno de estos:
        - marcado como @Initial:
        - tipos primitivos
        - tipos "simples" con valor por defecto definido: boxing types, String, collections
        - valor por defecto establecido con default method()
        - tipos @DataClass con constructor por defecto
        - Enumerados a primer elemento
    - se inicializa con un valor por defecto
    - ? "lazy": al invocar getter o "eager": al construir
    - propagar @Nullable a setters & constructors
    [x] propagar @Nonnull a setters???

[ ] Secondary constructors:
    - Se declaran en propia clase User:
        default User of(String name) {
            return $User.of(name, 0);
        }
    - En la clase $User se genera una copia:
        default User of(String name) {
            return User.of(name);
        }

[ ] Correct generation of nested classes

[ ] ? Optional support

[ ] Configuración sobre los paquetes en package-info.java que establece
    valores por defecto sobre @DataClass de los subpaquetes de forma jerarquica

[ ] Equals/HashCode/ToString generation

[ ] Inheritance
    - Generate MetaInterface that extends correspondent other MetaInterfaces
    - Si el campo del objeto es una clase no abstracta, se utiliza instancias para crearlo

[ ] Annotation propagation:
        @JsonProperty
        int property()
    Al generar bean se propaga a:
        - field
        - getter
        - setter
        - constructor parameter
    @Annotation(@JsonProperty("name"), propagate=[field, getter, constructor])

Collections
    ? como inyectar implementaciones custom ?
    Collections:
        - generate setters
            .names(T... names)
            .names(Collection<T> names)
            .name(T name)   <- add element to collection (depluralized)
    Maps:
        - generate setters
            .entities(Pair<K,V>... entries)
            .entitites(Map<K,V> entries)    <- detectar si el mapa es mutable, hacer copia para objetos inmutables
            .entity(Pair<K,V> entry)        <- put element to collection (depluralized)
            .entity(K key, V value)         <- put element to collection (depluralized)
    - Integración con librerias (guava, vavr, etc...)
    - Hacer propia implementación inmutable de List/Set/Map
    - Siempre iniciar con Collections.emptyCollection()
    - ??? @NotEmpty (1..n) control ???

[ ] ??? Field validators.
    - Based on JSR305???
    - Custom validation???


Metadata API
    Provide metadata api parecido a Kotlin
    - acceso estatico a propiedades
        Opcion 1 (code generation):
            UserMeta.name                   // : Property<T, V>, T = User, V = String
            UserMeta.contact                // : Property<T, V>, T = User, V = Contact
        Opcion 2 (sin generation):
            $(User::name)                   // : Property<?,V> ???
    - lista fija de propiedades
    - lista de propiedades y valores
    - Dynamic instantiator
        MetaClass.$init$                    // : (A, B, C, D) -> MetaClass


Al generar resolver tambien DataClassees compilados en otros paquetes:
    User:
        Contact contact();
    MUser:
        MContact contact();     // <-- MContact se necesita de ser resuelto
    La resolución funciona dentro del paquete, pero no con las classes de otro jar que ya estan compilados.


Data classes (immutables)

Delegates and Lazy

Nested (embedded) classes
    - poder mutar valores en embedded classes
        user.contactAddressStreet("").
    - para immutables hacer y devolver una copia de subarbol
    - idea: si contact/address no estan inicializados crearlos al acceder
        - Nunca se devuelven objetos NULL
        - Objetos Nested deben tener constructor vacío: Contact.of()
        - hashCode()/equals() deben tomar valor null del campo como objeto vacío:
            user.contact == null <=> user.contact == Contact.of()
        - no deben ser ni clase abstracta ni interface
    - se puede hacer truco devolviendo interfaz "trucada" que tracea mutaciones y establece al objeto padre

Beanpath
    - poder acceder usando beanpath: user.contact.address.street
        UserMeta.path(u -> u.contact().address().street())      // : Property<User, String>
            .set(user, "Lenina");
        user.path(u -> u.contact().address().street())          // : BoundPath<User, String>
            .set("Lenina")
        user = user.set(u -> u.name(), "Petya");
        user = user.set(User::name, "Petya");
        user.get("contact.address.street");
        $(User::contact).$(Contact::address).$(Address::street);
    - null guards: devolver nulo si alguno de

InitBlock
    - se ejecuta despues de constructor

Singletons (objects)

Custom Implementations:
    @CustomAccessor(MyAccessor.class)
    class MyAccessor implements CustomAccessor {
        Object create(Meta metaClass, Object... params) {}
        Object getValue(Object bean, Property property) {}
        Object setValue(Object bean, Property property, Object value) {}
    }
